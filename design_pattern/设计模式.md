# **设计模式**

## 一、面向对象设计原则

### 1、单一职责原则

-  定义：一个类只负责一个功能领域中的相应的职责，也就是说类的设计尽量只有一个原因引起变化。（最简单也应用最难运用的原则）


### 2、开闭原则

-  定义：一个软件实体应该对扩展的开放，对修改的关闭。也就是如何不修改原有的代码基础上，进行扩展。
- 规则：
  - 抽象约束
    - 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许接口或者抽象类存在非public方法。
    - 参数类型、引用类型尽量使用接口或者抽象类，而不是具体实现类。
    - 抽象层一定要保持稳定，一旦确定即不允许修改。
  - 元数据控制模型行为  
    - 基于配置文件实例化对象，例如spring的IOC

  - 制定项目章程
    - 制定出一套开发规范，避免后续难以扩展。
  - 封装变化
    - 把变化的部分放到抽象类或者接口上
    - 把不同变化，应该封装到不同变换接口或者抽象类上。

### 3、里氏代换原则

-  定义：在软件中使用基类（父类）替代它的子类，不会出现程序错误和异常，反过来则不成立。开发尽量使用基类，而不是子类，方便程序扩展。

-  子类完全实现父类的方法，如果不能满足父类所有方法，那么就脱离继承关系，改成依赖、组合、聚集等的方式替代。

- 子类可以有自己个性的方法。

### 4、依赖倒置原则

- 定义：抽象（接口和抽象类）不应该依赖细节（具体实现类），细节应该依赖于抽象。换言之，要面向接口编程，而不是实现编程。
- 实现依赖方式：
  - 构造函数传递依赖对象。
  - setter方式注入依赖对象。
  - 接口声明依赖对象（依赖注入）。
- 规则：
  - 每个类尽量有接口或者抽象类，或者两者都具备。
  - 变量的类型尽量是接口或者抽象类引用。
  - 任何类都不应该从具体类派生。
  - 尽量不要覆写基类的方法。

### 5、接口隔离原则

- 定义：使用多个专门接口（类似定制服务），而不是建立单一的总接口上。（普通类也属于接口，是实例接口）
  - 客户端不应该依赖那些它不需要的接口。
  - 类之间的依赖应该是在最小的接口上。
- 规则
  - 接口要尽量小
    - 接口隔离拆分粒度时，要满足单一职责原则。
  - 接口要高内聚
    - 高内聚就是提高接口、类和模块处理能力，减少对外界交互，言外之意尽量少的提供接口给外部。
  - 定制服务
    - 提供专门定制的接口。
  - 接口设计有限度
    - 接口粒度需要根据经验和常识判断，而不是一味小的的接口，带来结构复杂化。
- 实践
  - 一个接口只服用一个子模块或者业务逻辑。
  - 通过业务逻辑压缩接口public方法，而不是一堆方法。
  - 已经被污染的接口，尽量去修改，如果无法修改，采用适配器模式进行转化。
  - 了解环境，拒绝盲从，根据实际业务逻辑情况，而不是盲目跟风。

### 6、合成复用原则

- 定义：尽量使用对象组合，而不是继承来达到复用的原则。

### 7、迪米特原则

- 定义：一个软件实体尽可能少与其他实体发生相互作用，就是减少类之间相互依赖，降低类的耦合度，提高复用性。

## 二、创建型模式

### 1、单例模式

- 定义：确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

- 本质：控制实例的数目。

  - 优点
    - 只有一个实例，减少内存开支，避免频繁创建和销毁。
    - 提供全局访问点和共享资源访问。

  - 缺点
    - 不易扩展，代码复用性低。
    - 违法单一职责原则。

  - 场景
    - 要求生成唯一序列号的环境。
    - 大量静态常量和静态方法时，比如工具类。
    - 创建对象需要消耗大量资源，比如数据库和IO资源等。

- 实现：

  - 实现要点：

    - 私有化构造方法。

    - 获取实例化方法使用static方法。

    - 保证实例化对象线程安全。

    - 饿汉式模式

      ```java
      /**
       * 饿汉单例模式
       */
      public class EagerSingleton {
          
          private static final EagerSingleton instance = new EagerSingleton();
          
          private EagerSingleton() {
      
          }
          
          public static EagerSingleton getInstance() {
              return instance;
          }
      }
      ```

    - 懒汉式模式

      ```java
      /**
       * 懒汉式模式
       */
      public class LazySingleton {
      
          private static LazySingleton instance = null;
      
          private LazySingleton() {
      
          }
          
          public static synchronized LazySingleton getInstance() {
              if (instance == null) {
                  instance = new LazySingleton();
                  return instance;
              }
              return instance;
          }
      }
      ```

    - 双重检查锁

      ```java
      /**
       * 双重检查锁模式
       */
      public class DoubleCheckLockSingleton {
          /**
           * 解决指令重排和可见性
           */
          private static volatile DoubleCheckLockSingleton instance = null;
      
          private DoubleCheckLockSingleton() {
      
          }
      
          public static DoubleCheckLockSingleton getInstance() {
              if (instance == null) {
                  synchronized (DoubleCheckLockSingleton.class) {
                      if (instance == null) {
                          instance = new DoubleCheckLockSingleton();
                      }
                  }
              }
              return instance;
          }
      
      }
      ```
  
- 静态内部类模式
  
  ```java
      /**
       * 静态内部类实现
       */
      public class StaticInnerSingleton {
      
          private StaticInnerSingleton() {
      
          }
      
          private static class HoldClass {
              private final static StaticInnerSingleton instance = new StaticInnerSingleton();
          }
      
          private static StaticInnerSingleton getInstance() {
              return HoldClass.instance;
          }
      
          public static void main(String[] args) {
              StaticInnerSingleton singleton1 = StaticInnerSingleton.getInstance();
              StaticInnerSingleton singleton2 = StaticInnerSingleton.getInstance();
              StaticInnerSingleton singleton3 = StaticInnerSingleton.getInstance();
              System.out.println(singleton1 == singleton2);
              System.out.println(singleton1 == singleton3);
              System.out.println(singleton2 == singleton3);
          }
      }
  ```
  
- 枚举模式
  
  ```
   	 /**
       * 枚举模式
       */
      public enum EunmSingleton {
      
          instance;
      
          public static EunmSingleton getInstance() {
              return instance;
          }
          public static void main(String[] args) {
              EunmSingleton singleton1=EunmSingleton.getInstance();
              EunmSingleton singleton2=EunmSingleton.getInstance();
              EunmSingleton singleton3=EunmSingleton.getInstance();
              System.out.println(singleton1 == singleton2);
              System.out.println(singleton1 == singleton3);
              System.out.println(singleton2 == singleton3);
              /***
               * true
               * true
               * true
               */
          }
      }
  ```
  
  
  
- 破坏单例模式及解决方案
  
  - 单例实体
    
    ```java
    package com.ycz.pattern.singleton;
    
    import java.io.Serializable;
    
    /**
     * 懒汉式模式
     */
    public class LazySingleton implements Serializable {
    
        private static LazySingleton instance = null;
    
        private LazySingleton() {
     		if (instance == null) {
                throw new RuntimeException("禁止通过反射获取实例");
            }
        }
    
        public static synchronized LazySingleton getInstance() {
            if (instance == null) {
                instance = new LazySingleton();
                return instance;
            }
            return instance;
        }
    
        /**
         * 避免序列化后，序列化对象不是同一个对象破坏单例
         *  原理：
         *
         * @return
         */
        public LazySingleton readResolve() {
            return LazySingleton.getInstance();
        }
    }
    
    ```
    
    
    
  - 反射机制和序列化方式
  
    ```java
    package com.ycz.pattern.singleton;
    
    import java.io.*;
    import java.lang.reflect.Constructor;
    import java.lang.reflect.InvocationTargetException;
    
    /**
     * 破坏单例模式
     * 1.通过反射机制破坏单例模式（本质调用反射方法）
     *      解决办法：在构造函数中，判断实例是否存在，throw new RuntimeException("禁止通过反射获取实例");
     * 2.通过序列化方式破坏单例模式（本质调用反射方法）
     *      解决办法：(1)、被序列化对象不实现Serializable,对象不可序列化
     *              (2)、实现了序列化对象了，在该类中实现readResolve方法中返回单例对象，就不会被破坏单例
     *              示例：
     *              private Object readResolve(){
     *                  //当前类的单例对象
     *                  return hungrySingleton;
     *             }
     *
     * @author ycz
     */
    public class BreakSingleton {
    
        public static void main(String[] args) throws Exception {
            //1、反射方式进行破坏单例模式
            // invoke();
            //2、序列化方式破坏单例模式
            serializable();
    
        }
    
        /**
         * 序列化方式
         */
        private static void serializable() throws Exception {
            //获取单例实例
            LazySingleton instance = LazySingleton.getInstance();
            //通过序列化获取实例
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("lazy_singleton_file"));
            objectOutputStream.writeObject(instance);
            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(new File("lazy_singleton_file")));
            LazySingleton newInstance = (LazySingleton) objectInputStream.readObject();
            System.out.println("单例中获取:" + instance);
            System.out.println("序列化对象:" + newInstance);
            System.out.println(instance == newInstance);
        }
    
        /**
         * 反射方式
         */
        private static void invoke() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
            Class<LazySingleton> singletonClass = LazySingleton.class;
            Constructor<LazySingleton> declaredConstructor = singletonClass.getDeclaredConstructor();
            declaredConstructor.setAccessible(true);
            LazySingleton newInstance = declaredConstructor.newInstance();
            LazySingleton instance = LazySingleton.getInstance();
            System.out.println(instance);
            System.out.println(newInstance);
            System.out.println(instance == newInstance);
            /**
             * com.ycz.pattern.singleton.LazySingleton@4554617c
             * com.ycz.pattern.singleton.LazySingleton@74a14482
             * false
             */
            Class<EagerSingleton> eagerSingletonClass = EagerSingleton.class;
            EagerSingleton eagerSingleton = EagerSingleton.getInstance();
            EagerSingleton newEagerSingleton = eagerSingletonClass.newInstance();
            System.out.println(eagerSingleton == newEagerSingleton);
        }
    }
    ```
  
  

### 2、简单工厂模式

- 定义：定义一个工厂类，根据参数不同返回不同的实例，返回被创建的实例都有共同的父类。因为工厂类中的获取实例的方法是静态（static）方法，也被称静态工厂方法模式。

- 本质：根据参数选择具体产品实现。

- 类图：

  ![](https://i.loli.net/2020/06/11/ED8Y9XhwsZMSKiO.png)

  - Factory（工厂角色）：负责创建具体产品实例化对象，提供静态工厂方法给外部调用，返回抽象产品类型Product。
  - Product（抽象产品角色）：产品抽象类，具体产品的父类，提供公有方法。
  - ConcreateProduct（具体产品角色）：具体产品继承抽象类，具体实例化的产品。

- 实现：

  ```
  /**
   * 抽象产品类
   */
  public abstract class Product {
      /**
       * 抽象产品
       */
      abstract void operate();
  }
  ```

  ```
  /**
   * 具体产品类
   */
  public class ConCreateProduct extends Product {
  
      @Override
      void operate() {
          System.out.println("ConCreateProduct Instance  Success");
      }
  }
  ```

  ```
  /**
   * 工厂类
   */
  public class SimpleFactory {
      /**
       * 抽象静态工厂方法
       *
       * @param type
       * @return
       */
      public static Product createProduct(int type) {
          if (type == 1) {
              return new ConCreateProduct();
          }
          throw new RuntimeException("type  no exist instance ,  check please!");
      }
  }
  ```

  ```java
  /**
   * 客户端
   */
  public class Client {
  
      public static void main(String[] args) {
          Product product = SimpleFactory.createProduct(2);
          product.operate();
      }
  }
  
  ```

### **3、简单工厂方法模式**

- 定义：定义一个用于创建对象的接口，让子类决定哪个类进行实例化。

- 本质：延迟到子类选择实现。

- 类图：

  ![](https://i.loli.net/2020/06/11/CfRhQeEnD13sZyU.png)

  - Product（抽象产品）：抽象产品类，封装产品公共方法和抽象方法，延迟到子类实现。
  - ConcreateProduct（具体产品）：实现抽象产品类，具体产品与具体工厂类一一对应。
  - AbstractFactory（抽象工厂）：抽象工厂类，封装工厂方法，具体实现延迟到子类，返回一个产品。
  - ConcreateFactory（具体工厂类）：实现抽象工厂类，实现抽象方法，返回具体产品的实例。

- 实现：

  ```java
  /**
   * 抽象产品
   */
  abstract class Product {
      /**
       * 产品公共方法
       */
      abstract void show();
  }
  ```

  ```java
  
  /**
   * 具体产品A实现
   */
  public class ConcreateProductA extends Product {
      @Override
      void show() {
          System.out.println("show A product.....");
      }
  }
  ```

  ```java
  /**
   * 具体产品B实现
   */
  public class ConcreateProductB extends Product {
      @Override
      void show() {
          System.out.println("show B product.....");
      }
  }
  ```

  ```java
  /**
   * 抽象工厂类
   */
  public abstract class AbstractFactory {
      /**
       * 抽象工厂方法一
       *
       * @param tClass
       * @param <T>
       * @return
       */
      abstract <T extends Product> T createProduct(Class<T> tClass);
      /**
       * 抽象工厂方法二
       * @return
       */
      abstract Product createProduct();
  }
  ```

  ```java
  /**
   * 具体产品实现类
   */
  public class ConcreateFactoryA extends AbstractFactory {
  
      private static final Logger logger = LoggerFactory.getLogger(ConcreateFactoryA.class);
  
      @Override
      <T extends Product> T createProduct(Class<T> tClass) {
          try {
              return (T) Class.forName(tClass.getName()).newInstance();
          } catch (Exception e) {
              logger.error("new instance,exception{}", e.getMessage());
          }
          return null;
      }
       @Override
      Product createProduct() {
          return new ConcreateProductA();
      }
  }
  ```

  ```java
  /**
   * 具体B产品抽象工厂类
   */
  public class ConcreateFactoryB extends AbstractFactory {
  
      private static final Logger logger = LoggerFactory.getLogger(ConcreateFactoryB.class);
  
      @Override
      <T extends Product> T createProduct(Class<T> tClass) {
          try {
              return (T) Class.forName(tClass.getName()).newInstance();
          } catch (Exception e) {
              logger.error("new instance,exception:{}", e.getMessage());
          }
          return null;
      }
       @Override
      Product createProduct() {
          return new ConcreateProductB();
      }
  }
  ```

### 4、抽象工厂模式

- 定义：定义一系列抽象方法或相互依赖对象的接口，而无需指定具体产品类。

- 本质：选择产品簇的实现。

- 类图：

  ![](https://i.loli.net/2020/06/11/katfHujMlW2c5yG.png)

  - AbstractFactory(抽象工厂)：创建一系列抽象方法，每个方法对应着一个具体产品。
  - ConcreateFactory(具体工厂)：实现抽象工厂方法，并创建具体产品。
  - AbstractProduct(抽象产品)：定义抽象产品方法和公共业务方法。
  - ConcreateProduct(具体产品)：具体产品实现抽象产品业务方法。

- 实现：

  ```java
  /**
   * 抽象工厂方法
   */
  public abstract class AbstractFactory {
      /**
       * 抽象产品A
       *
       * @return
       */
      public abstract AbstractProductA createProductA();
  
      /**
       * 抽象产品B
       *
       * @return
       */
      public abstract AbstractProductB createProductB();
  }
  ```

  ```java
  /**
   * 创建产品A
   */
  public class ConcreateFactoryProductA extends AbstractFactory {
      @Override
      public AbstractProductA createProductA() {
          return new ProductA1();
      }
  
      @Override
      public AbstractProductB createProductB() {
          return new ProductB1();
      }
  }
  ```

  ```java
  
  /**
   * 创建产品B
   */
  public class ConcreateFactoryProductB extends AbstractFactory {
      @Override
      public AbstractProductA createProductA() {
          return new ProductA2();
      }
  
      @Override
      public AbstractProductB createProductB() {
          return new ProductB2();
      }
  }
  ```

  ```java
  /**
   * 抽象产品A
   */
  public abstract class AbstractProductA {
      /**
       * 抽象产品公用类
       */
      public abstract void show();
  }
  ```

  ```java
  public class ProductA1 extends AbstractProductA {
      @Override
      public void show() {
          System.out.println("产品A1...........");
      }
  }
  ```

  ```java
  public class ProductA2 extends AbstractProductA {
      @Override
      public void show() {
          System.out.println("产品A2........");
      }
  }
  ```

  ```java
  /**
   * 抽象产品B
   */
  public abstract class AbstractProductB {
      /**
       * 抽象类公共方法
       */
      public abstract void show();
  }
  ```

  ```java
  public class ProductB1 extends AbstractProductB {
      @Override
      public void show() {
          System.out.println("产品B1.....");
      }
  }
  ```

  ```java
  public class ProductB2 extends AbstractProductB {
      @Override
      public void show() {
          System.out.println("产品B2.........");
      }
  }
  ```

### **5、原型模式**

- 定义：克隆生成原型（需要克隆实体）的实例，也就是克隆生成定义好的原型实例。

- 本质：克隆生成对象

- 类图：![](https://i.loli.net/2020/06/11/nOlaZfcCohMpSLY.png)

  - Prototype（抽象原型类）：相当于定义一个clone方法的接口，可以是接口、抽象或者具体的实现类。
  - ConcretePrototype（具体原型类）：具体实现了clone方法，返回自己克隆后的对象。
  - Client（客户端类）：调用具体原型类，返回克隆后的对象。

- 实现：

  - 浅拷贝：Object.clone()方法只是浅克隆，如果要使用Object.clone()方法，该类必须实现Cloneable接口。否则，调用clone方法会抛出CloneNotSupportedException异常，克隆对象的属性值，其中基本类型和String都是进行深拷贝，String类型是常量final类，如果修改克隆后的对象，相当于创建new String("abc")，所以也进行拷贝。如果原型类包含引用对象，而克隆后对象对该引用对象进行修改，会把原型对象的引用对象的值改变，引用类型只是进行浅拷贝，克隆后的对象还是同一个内存地址引用。

    ```java
    /**
     * 原型类(浅拷贝)
     */
    public class Prototype implements Cloneable {
        private int age;
        private String name;
        /**
         * 引用类型对象
         */
        private Detail detail;
    
        public Detail getDetail() {
            return detail;
        }
    
        public void setDetail(Detail detail) {
            this.detail = detail;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    	/**
         * 重写clone()方法
         * @return
         * @throws CloneNotSupportedException
         */
        @Override
        protected Object clone() throws CloneNotSupportedException {
            Prototype prototype = (Prototype) super.clone();
            return prototype;
        }
        @Override
        public String toString() {
            return "Prototype{" +
                    "age=" + age +
                    ", name='" + name + '\'' +
                    ", detail=" + detail +
                    '}';
        }
    
        public static void main(String[] args) throws CloneNotSupportedException {
            Prototype prototype = new Prototype();
            prototype.setAge(20);
            prototype.setName("张三");
            prototype.setDetail(new Detail("abc", new Date(1000000000000L)));
            System.out.println("源对象:" + prototype);
            System.out.println("===================================================");
            Prototype prototype1 = (Prototype) prototype.clone();
            Detail detail = prototype1.getDetail();
            detail.setMsg("DEF");
            System.out.println("克隆后，修改引用类型后：" + prototype1);
            System.out.println("===================================================");
            System.out.println("修改克隆对象后，源对象：" + prototype);
            /**
             * 源对象:Prototype{age=20, name='张三', detail=Detail{msg='abc', date=Sun Sep 09 09:46:40 CST 2001}}
             * ====================================================
             * 克隆后，修改引用类型后：Prototype{age=20, name='张三', detail=Detail{msg='DEF', date=Sun Sep 09 09:46:40 CST 2001}}
             * ====================================================
             * 修改克隆对象后，源对象：Prototype{age=20, name='张三', detail=Detail{msg='DEF', date=Sun Sep 09 09:46:40 CST 2001}}
             */
        }
    }
    ```

    ```java
    /**
     * 引用类型对象
     */
    public class Detail implements Cloneable {
        private String msg;
        private Date date;
    
        public Detail(String msg, Date date) {
            this.msg = msg;
            this.date = date;
        }
    
        public String getMsg() {
            return msg;
        }
    
        public void setMsg(String msg) {
            this.msg = msg;
        }
    
        public Date getDate() {
            return date;
        }
    
        public void setDate(Date date) {
            this.date = date;
        }
    	/**
         * 重写clone()方法
         * @return
         * @throws CloneNotSupportedException
         */
        @Override
        protected Detail clone() throws CloneNotSupportedException {
            return (Detail) super.clone();
        }
    
        @Override
        public String toString() {
            return "Detail{" +
                    "msg='" + msg + '\'' +
                    ", date=" + date +
                    '}';
        }
    }
    ```

  - 深拷贝：如果要进行深拷贝，原型类中包含引用类型对象，都需要进行实现Cloneable接口，重写clone方法，深拷贝后对象的内存引用地址不是同一个地址，即使改动克隆后的对象，也不会改变原型对象的引用对象的内容。

    - 采用实现cloneable方式

      ```java
      /**
       * 深拷贝：实现Cloneable接口，重新clone方法，引用对象也需要重新clone方法才能进行深拷贝
       */
      public class User implements Cloneable {
          private int age;
          private String name;
          /**
           * 需要进行深拷贝
           */
          private UserDetail userDetail;
      
          public UserDetail getUserDetail() {
              return userDetail;
          }
      
          public void setUserDetail(UserDetail userDetail) {
              this.userDetail = userDetail;
          }
      
          public int getAge() {
              return age;
          }
      
          public void setAge(int age) {
              this.age = age;
          }
      
          public String getName() {
              return name;
          }
      
          public void setName(String name) {
              this.name = name;
          }
      
          /**
           * 重写clone方法，引用对象进行深拷贝
           * @return
           * @throws CloneNotSupportedException
           */
          @Override
          protected User clone() throws CloneNotSupportedException {
              User user = (User) super.clone();
              user.setUserDetail(this.userDetail.clone());
              return user;
          }
      }
      ```

      ```java
      /**
       * 引用类型对象
       */
      public class UserDetail implements Cloneable {
          private String msg;
          private Date date;
      
          public UserDetail(String msg, Date date) {
              this.msg = msg;
              this.date = date;
          }
      
          public String getMsg() {
              return msg;
          }
      
          public void setMsg(String msg) {
              this.msg = msg;
          }
      
          public Date getDate() {
              return date;
          }
      
          public void setDate(Date date) {
              this.date = date;
          }
      
          /**
           * 重新clone方法
           *
           * @return
           * @throws CloneNotSupportedException
           */
          @Override
          protected UserDetail clone() throws CloneNotSupportedException {
              return (UserDetail) super.clone();
          }
      }
      ```

    - 采用序列化方式（必须实现Serializable接口）

      ```java
      /**
       * 采用序列化方式进行深拷贝
       */
      public class DeepClone implements Serializable {
          private String name;
          private int age;
          private DeepCloneDetail deepCloneDetail;
      
          public DeepClone(String name, int age) {
              this.name = name;
              this.age = age;
          }
      
          public DeepCloneDetail getDeepCloneDetail() {
              return deepCloneDetail;
          }
      
          public void setDeepCloneDetail(DeepCloneDetail deepCloneDetail) {
              this.deepCloneDetail = deepCloneDetail;
          }
      
          /**
           * 序列化方式，进行深拷贝
           *
           * @return
           */
          protected DeepClone deepClone() throws IOException, ClassNotFoundException {
              ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
              ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);
              outputStream.writeObject(this);
              ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
              ObjectInputStream inputStream = new ObjectInputStream(byteArrayInputStream);
              return (DeepClone) inputStream.readObject();
          }
      
          @Override
          public String toString() {
              return "DeepClone{" +
                      "name='" + name + '\'' +
                      ", age=" + age +
                      ", deepCloneDetail=" + deepCloneDetail +
                      '}';
          }
      
          public static void main(String[] args) throws IOException, ClassNotFoundException {
              DeepClone deepClone = new DeepClone("张三", 10);
              deepClone.setDeepCloneDetail(new DeepCloneDetail("ABC"));
              System.out.println("原类型对象：" + deepClone);
              DeepClone deepClone1 = deepClone.deepClone();
              DeepCloneDetail deepCloneDetail = deepClone1.getDeepCloneDetail();
              deepCloneDetail.setDesc("DEF");
              System.out.println("克隆后对象：" + deepClone1);
              deepClone1.setDeepCloneDetail(deepCloneDetail);
              System.out.println("克隆后修改引用对象后，原类型对象：" + deepClone);
          }
      }
      ```

      ```java
      
      /**
       * 引用类型对象
       */
      public class DeepCloneDetail implements Serializable {
          private String desc;
      
          public DeepCloneDetail(String desc) {
              this.desc = desc;
          }
      
          public String getDesc() {
              return desc;
          }
      
          public void setDesc(String desc) {
              this.desc = desc;
          }
      
          @Override
          public String toString() {
              return "DeepCloneDetail{" +
                      "desc='" + desc + '\'' +
                      '}';
          }
      }
      ```

      

### **6、建造者模式**

- 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。就是将对象创建构成的部件分离，延迟到子类实现。

- 本质：分离整体构建算法和部件构造。

- 类图：

  ![](https://i.loli.net/2020/06/11/kFHouerIKTnA7Um.png)

  - Director（指挥者）:负责复杂对象构建次序，和Builder进行关联关系，调用construct方法编写Builder的部件构建次序，完成复杂产品。
  - Builder（抽象建造者）：定义具体方法实现和抽象部件方法，延迟到子类实现，getResult()返回具体Product实例。
  - ConcreteBuilder（具体建造者）：实现抽象建造者，构建抽象部件方法，返回具体产品实例。
  - Product（抽象产品）：可以是具体产品，也可以是抽象产品，复杂产品构建的最终实例。

- 实现：

  ```java
  package com.learn.design.pattern.builder;
  
  /**
   * @author ycz
   * @version 1.0
   * @date 2020/5/8 11:00
   * @desc 指挥者
   */
  public class Director {
  
      private Builder builder;
  
      public Director(Builder builder) {
          this.builder = builder;
      }
  
      public Product createProduct() {
          builder.buildColour();
          //钩子
          if (builder.isBuildHair()) {
              builder.buildHair();
          }
          return builder.getProduct();
      }
  }
  ```

  ```java
  package com.learn.design.pattern.builder;
  
  /**
   * @author ycz
   * @version 1.0
   * @date 2020/5/8 11:01
   * @desc 抽象建造者
   */
  public abstract class Builder {
      /**
       * 具体产品
       */
      protected Product product = new Product();
  
      /**
       * 构建肤色
       */
      public abstract void buildColour();
  
      /**
       * 构建头发
       */
      public abstract void buildHair();
  
      /**
       * 具体产品（如果产品是抽象类，定义抽象方法延迟到子类构建）
       *
       * @return
       */
      public Product getProduct() {
          return product;
      }
  
      /**
       * 默认构建头发（钩子）
       *
       * @return
       */
      public boolean isBuildHair() {
          return true;
      }
  }
  ```

  ```java
  package com.learn.design.pattern.builder;
  
  /**
   * @author ycz
   * @version 1.0
   * @date 2020/5/8 11:06
   * @desc 黑人建造者
   */
  public class BlackBuilder extends Builder {
      @Override
      public void buildColour() {
          super.product.setColour("黑色");
      }
  
      @Override
      public void buildHair() {
          super.product.setHair("卷毛");
      }
  
  }
  ```

  ```java
  package com.learn.design.pattern.builder;
  
  /**
   * @author ycz
   * @version 1.0
   * @date 2020/5/8 11:06
   * @desc 白人具体构建者
   */
  public class WhiteBuilder extends Builder {
      private boolean isBuilderHair;
  
      public WhiteBuilder(boolean isBuilderHair) {
          this.isBuilderHair = isBuilderHair;
      }
  
      @Override
      public void buildColour() {
          super.product.setColour("白色");
      }
  
      @Override
      public void buildHair() {
          super.product.setHair("金毛");
      }
  
      /**
       * 钩子如果设置成false就不构建具体部件
       *
       * @return
       */
      @Override
      public boolean isBuildHair() {
          return isBuilderHair;
      }
  }
  ```

  ```java
  package com.learn.design.pattern.builder;
  
  /**
   * @author ycz
   * @version 1.0
   * @date 2020/5/8 11:02
   * @desc 产品（具体产品或者抽象产品）
   */
  public class Product {
      /**
       * 肤色
       */
      private String colour;
      /**
       * 头发
       */
      private String hair;
  
      public Product() {
      }
  
      public Product(String colour, String hair) {
          this.colour = colour;
          this.hair = hair;
      }
  
      public String getColour() {
          return colour;
      }
  
      public void setColour(String colour) {
          this.colour = colour;
      }
  
      public String getHair() {
          return hair;
      }
  
      public void setHair(String hair) {
          this.hair = hair;
      }
  
      @Override
      public String toString() {
          return "Product{" +
                  "colour='" + colour + '\'' +
                  ", hair='" + hair + '\'' +
                  '}';
      }
  }
  
  ```

  ```java
  package com.learn.design.pattern.builder;
  /**
   * @author ycz
   * @version 1.0
   * @date 2020/5/8 11:20
   * @desc 测试客户端
   */
  public class Client {
  
      public static void main(String[] args) {
          //是否构建头发 false/true
          Builder builder = new WhiteBuilder(false);
          Director director = new Director(builder);
          Product product = director.createProduct();
          System.out.println(product);
          Builder builder1 = new BlackBuilder();
          Director director1 = new Director(builder1);
          Product product1= director1.createProduct();
          System.out.println(product1);
      }
  }
  ```

  

## 二、结构型模式

### 1、适配器模式

- 定义：将一个类的接口变换成客户希望的另一个接口上，使接口不兼容的那些类可以一起工作。也叫做包装器（Wrapper）。

- 本质：转换匹配，复用功能。

- 场景：想修改已经投产中接口，不符合原有设计的时候才考虑适配器模式，一定要记住不能违反依赖倒置原则和里氏代换原则。

- 类图：

  ![](https://i.loli.net/2020/06/11/fBwdanVqtpXmMKy.png)

  - Target（目标抽象类）：给客户提供的可以直接调用的类，可以是接口、抽象类或者具体的类，当然接口和抽象类比较合适，方便后续的扩展。
  - Adapter（适配器类）：可以调用另一个接口类，做匹配转换，适配器模式的核心。该可以是接口、抽象类或者具体的类，可以通过继承Adaptee对象，实现Target接口，这种方式被称作为类适配器。
  - Adaptee（适配者类）：该类被适配的角色，一般情况下该类是具体实现类，当然可以是接口或者抽象类，在特殊的情况下，可以不需要适配者类，直接交给Adapter实现代码。

- 实现：

  - 对象适配器：

    ```java
    package com.learn.design.pattern.adapter;
    
    /**
     * 目标抽象类
     * @author ycz
     * @version 1.0
     * @date 2020/5/11 23:28
     * @desc
     */
    public interface Target {
        /**
         * 请求接口
         */
        public void request();
    }
    
    ```

    ```java
    package com.learn.design.pattern.adapter;
    
    /**
     * 适配器类
     *
     * @author ycz
     * @version 1.0
     * @date 2020/5/11 23:29
     * @desc
     */
    public class Adapter implements Target {
        //被适配者
        private Adaptee adaptee;
    
        public Adapter(Adaptee adaptee) {
            this.adaptee = adaptee;
        }
    
        @Override
        public void request() {
            System.out.println("调用适配器");
            adaptee.specialRequest();
        }
    }
    ```

    ```java
    package com.learn.design.pattern.adapter;
    
    /**
     * 适配者类
     *
     * @author ycz
     * @version 1.0
     * @date 2020/5/11 23:29
     * @desc
     */
    public class Adaptee {
        /**
         * 具体实现
         */
        public void specialRequest() {
            System.out.println("适配者类接口调用");
        }
    }
    ```

    ```java
    package com.learn.design.pattern.adapter;
    
    /**
     * 客户端类
     *
     * @author ycz
     * @version 1.0
     * @date 2020/5/11 23:34
     * @desc
     */
    public class AdapterClient {
    
        public static void main(String[] args) {
            Adaptee adaptee = new Adaptee();
            Target target = new Adapter(adaptee);
            target.request();
        }
    }
    ```

  - 类适配器：

    ```java
    /**
     * 类适配器
     *
     * @author ycz
     * @version 1.0
     * @date 2020/5/11 23:37
     * @desc
     */
    public class ClassAdapter extends Adaptee implements Target {
        @Override
        public void request() {
            super.specialRequest();
        }
    }
    ```

  - 双向适配器：

    ```java
    package com.learn.design.pattern.adapter;
    
    /**
     * 双向适配器
     *
     * @author ycz
     * @version 1.0
     * @date 2020/5/11 23:40
     * @desc
     */
    public class DuplexAdapter {
        /**
         * 目标类
         */
        private Target target;
        /**
         * 被适配者类
         */
        private Adaptee adaptee;
    
        public DuplexAdapter(Target target, Adaptee adaptee) {
            this.target = target;
            this.adaptee = adaptee;
        }
    
        /**
         * 调用被适配者
         */
        public void specialRequest() {
            adaptee.specialRequest();
        }
    
        /**
         * 调用目标类
         */
        public void request(){
            target.request();;
        }
    }
    ```

  - 缺省适配器：

    - 定义：当不需要实现一个接口的所有方法时，可先设计一个抽象类实现该接口，抽象类中实现默认空方法或者定义一些自定义的异常抛出，由该抽象类的子类实现某些方法的实现需求。
    
      ```java
      package com.learn.design.pattern.adapter;
      
      /**
       * 目标接口类（也可以抽象类）
       *
       * @author ycz
       * @version 1.0
       * @date 2020/5/12 22:00
       * @desc
       */
      public interface ServiceInterface {
          /**
           * 请求接口
           */
          public void request();
      }
      
      ```
    
      ```java
      package com.learn.design.pattern.adapter;
      
      /**
       * 缺省适配器
       *
       * @author ycz
       * @version 1.0
       * @date 2020/5/12 22:02
       * @desc
       */
      abstract class DefaultInterface implements ServiceInterface {
      
          @Override
          public void request() {
              //可以空实现或者自定义异常类
          }
      }
      ```
    
      ```java
      package com.learn.design.pattern.adapter;
      
      /**
       * 具体实现类
       * @author ycz
       * @version 1.0
       * @date 2020/5/12 22:05
       * @desc
       */
      public class ConcreteInterface extends DefaultInterface {
          @Override
          public void request() {
              System.out.println("重写缺省接口");
          }
      }
      ```
    
      

### 2、桥接模式

- 定义：将抽象部分和实现部分进行分离，可以独立进行多维度变化。

- 本质：分离抽象与实现

- 类图：

  ![](https://i.loli.net/2020/06/11/BgjpDU9eosLcyR1.png)

  - Abstraction（抽象类）：是一个抽象类，定义业务方法，与implementor存在关联关系。
  - RefinedAbstraction（扩充抽象类）：实现Abstraction类的具体类，可以直接调用Implementor接口实现。
  - Implementor（实现类接口）：定义自己实现类接口，便于Abstraction类和它的子类调用，独立自己的维度变化。
  - ConcreteImplementor（具体实现类）：实现类接口的具体类，实现了接口方法，提供给Abstraction类和它的子类调用。

- 实现：	

  ```java
  package com.learn.design.pattern.bridge;
  
  /**
   * 抽象类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/16 17:23
   * @desc
   */
  public abstract class Abstraction {
  
      protected Implementor implementor;
  
      public Abstraction(Implementor implementor) {
          this.implementor = implementor;
      }
  
      /**
       * 操作接口
       */
      public abstract void operation();
  }
  ```

  ```java
  package com.learn.design.pattern.bridge;
  
  /**
   * 扩充抽象类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/16 17:24
   * @desc
   */
  public class RefinedAbstraction extends Abstraction {
      /**
       * 构造函数传递具体实现类
       *
       * @param implementor
       */
      public RefinedAbstraction(Implementor implementor) {
          super(implementor);
      }
  
      @Override
      public void operation() {
          System.out.println("扩充抽象类。。。。");
          implementor.operationImpl();
      }
  }
  ```

  ```java
  package com.learn.design.pattern.bridge;
  
  /**
   * 实现类接口
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/16 17:26
   * @desc
   */
  public interface Implementor {
      /**
       * 抽象类接口
       */
      void operationImpl();
  }
  ```

  ```java
  package com.learn.design.pattern.bridge;
  
  /**
   * 具体实现接口类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/16 17:28
   * @desc
   */
  public class ConcreteImpl implements Implementor {
      @Override
      public void operationImpl() {
          System.out.println("调用实现类。。。。。");
      }
  }
  ```

### 3、组合模式

- 定义：组合多个对象形成树形结构以表示“整体-部分”的关系层次结构。

- 本质：统一叶子对象和组合对象。

- 类图：

  ![](https://i.loli.net/2020/06/11/T1iMo6qrjz2uvGf.png)

  - Component（抽象构件）：可以是接口或者抽象类，提供叶子构件和组合构件声明接口方法。还有两者公共方法operation()。
  - Leaf（叶子构件）：表示叶子节点对象，实现了抽象构件的方法。
  - Composite（容器构件）:表示容器节点对象，容器节点可以是子节点，也可以是叶子节点。提供一个集合用于存储子节点，实现抽象构件方法。

- 实现：

  ```java
  package com.learn.design.pattern.composite;
  
  /**
   * 抽象构件
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/17 17:10
   * @desc
   */
  public abstract class Component {
      /**
       * 节点名称
       */
      protected String name;
  
      public Component(String name) {
          this.name = name;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      /**
       * 公共抽象方法
       */
      public abstract void operation();
  
      /**
       * 添加节点
       *
       * @param component
       */
      public abstract void add(Component component);
  
      /**
       * 删除节点
       *
       * @param component
       */
      public abstract void remove(Component component);
  
      /**
       * 获取节点
       *
       * @param i
       * @return
       */
      public abstract Component getChild(int i);
  }
  ```

  ```java
  package com.learn.design.pattern.composite;
  
  import java.util.ArrayList;
  import java.util.List;
  
  /**
   * 容器节点对象
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/16 23:43
   * @desc
   */
  public class Composite extends Component {
      //存储容器节点
      private List<Component> componentList = new ArrayList<>();
  
      public Composite(String name) {
          super(name);
      }
  
      @Override
      public void operation() {
          System.out.println("++" + name);
          for (Object object : componentList) {
              ((Component) object).operation();
          }
      }
  
      @Override
      public void add(Component component) {
          componentList.add(component);
      }
  
      @Override
      public void remove(Component component) {
          componentList.remove(component);
      }
  
      @Override
      public Component getChild(int i) {
          return componentList.get(i);
      }
  }
  ```

  ```java
  package com.learn.design.pattern.composite;
  
  /**
   * 叶子节点
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/17 17:12
   * @desc
   */
  public class Leaf extends Component {
  
      public Leaf(String name) {
          super(name);
      }
  
      @Override
      public void operation() {
          System.out.println("-----" + name + "----");
      }
  
      @Override
      public void add(Component component) {
          throw new UnsupportedOperationException("不支持该功能");
      }
  
      @Override
      public void remove(Component component) {
          throw new UnsupportedOperationException("不支持该功能");
      }
  
      @Override
      public Component getChild(int i) {
          throw new UnsupportedOperationException("不支持该功能");
      }
  }
  ```

  ```java
  package com.learn.design.pattern.composite;
  
  /**
   * 客户端测试类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/17 17:27
   * @desc
   */
  public class Client {
      public static void main(String[] args) {
          Component component, component1, leaf;
          component = new Composite("服装");
          component1 = new Composite("男装");
          leaf = new Leaf("衣服");
          component1.add(leaf);
          component.add(component1);
          component.operation();
      }
  }
  ```

  

### 4、装饰模式

- 定义：动态给对象增加额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。

- 本质：动态组合

- 类图：

  ![](https://i.loli.net/2020/06/11/tRsmGqop3UzH8WI.png)

  - Component（抽象构件类）：它是具体构件类和抽象装饰类的共同的父类，定义具体构件类的实现业务方法。
  - ConcreteComponent（具体构件类）:实现抽象构件类的方法，具体构件类需要被装饰的对象。
  - Decorator（抽象装饰类）：它是抽象构件类的子类，持有抽象构件类的引用，它的子类可以新增对象职责。
  - ConcreteDecorator（具体装饰类）:它是抽象装饰类的子类，新增对象的职责。

- 实现：

  ```java
  package com.learn.design.pattern.decorator;
  
  /**
   * 抽象构件类（Component的角色）
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/17 23:28
   * @desc
   */
  public abstract class UserService {
      /**
       * 登录系统
       * @param userName
       */
      public abstract void login(String userName);
  }
  ```

  ```java
  package com.learn.design.pattern.decorator;
  
  /**
   * 具体构件类子类(ConcreteComponent)
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/17 23:30
   * @desc
   */
  public class UserServiceImpl extends UserService {
      @Override
      public void login(String userName) {
          System.out.println("用户:" + userName + "，登录成功");
      }
  }
  ```

  ```java
  package com.learn.design.pattern.decorator;
  
  /**
   * 抽象装饰类（Decorator类）
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/17 23:32
   * @desc
   */
  public abstract class UserDecorator extends UserService {
      //装饰器的核心
      private UserService userService;
  
      public UserDecorator(UserService userService) {
          this.userService = userService;
      }
  
      @Override
      public void login(String userName) {
          userService.login(userName);
      }
  }
  ```

  ```java
  package com.learn.design.pattern.decorator;
  
  /**
   * 具体装饰器类的子类（ConcreteDecorator）
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/17 23:37
   * @desc
   */
  public class UserLogRecordDecorator extends UserDecorator {
  
      public UserLogRecordDecorator(UserService userService) {
          super(userService);
      }
  
      @Override
      public void login(String userName) {
          recordLog(userName);
          super.login(userName);
      }
  
      /**
       * 增加AOP功能，给用户登录新增职责（记录登录日志）
       *
       * @param userName
       */
      public void recordLog(String userName) {
          System.out.println("记录用户：" + userName + "登录日志");
      }
  }
  ```

  ```java
  package com.learn.design.pattern.decorator;
  
  /**
   * 客户端类--测试类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/17 23:43
   * @desc
   */
  public class DecoratorTest {
  
      public static void main(String[] args) {
          UserService  userService1=new UserLogRecordDecorator(new UserServiceImpl());
          userService1.login("李四");
      }
  }
  ```
  
  

### 5、外观模式

- 定义：外部与一个子系统交互时，提供统一高层接口，这个接口更加容易使用子系统接口。也就是提供高层接口，屏蔽内部各个子系统交互逻辑，外部只要调用高层接口就可以。

- 本质：封装交互，简单调用。

- 类图：

  ![](https://i.loli.net/2020/06/11/Kds2qmP6wrV9GYH.png)

  - Facade（外观角色）：提供给客户端调用的接口，内部有相应的子系统调用的接口和功能。
  - SubSystem（子系统角色）：各个子系统相应处理逻辑，提供给外观类使用。

- 实现：

  ```java
  package com.learn.design.pattern.facade;
  
  /**
   * 统一外观接口（也可以时抽象类）
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/13 22:29
   * @desc
   */
  public interface Facade {
      /**
       * 统一入口方法
       */
      public void request();
  }
  ```

  ```java
  package com.learn.design.pattern.facade;
  
  /**
   * 统一外观接口实现
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/13 22:37
   * @desc
   */
  public class FadeImpl implements Facade {
      /**
       * 子系统A （最好使用接口类或者抽象类便于后续扩展）
       */
      private SystemA systemA;
      /**
       * 子系统B （最好使用接口类或者抽象类便于后续扩展）
       */
      private SystemB systemB;
  
      public FadeImpl(SystemA systemA, SystemB systemB) {
          this.systemA = systemA;
          this.systemB = systemB;
      }
  
      @Override
      public void request() {
          systemA.requestA();
          systemB.requestB();
      }
  }
  ```

  ```java
  package com.learn.design.pattern.facade;
  
  /**
   * 子系统A
   * @author ycz
   * @version 1.0
   * @date 2020/5/13 22:36
   * @desc
   */
  public class SystemA {
      /**
       * 子系统方法
       */
      public void requestA() {
          System.out.println("调用子系统A执行");
      }
  }
  ```

  ```java
  package com.learn.design.pattern.facade;
  
  /**
   * 子系统B
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/13 22:36
   * @desc
   */
  public class SystemB {
      /**
       * 子系统B方法
       */
      public void requestB() {
          System.out.println("调用子系统B方法");
      }
  }
  ```

### 6、享元模式

- 定义：运用共享技术有效地支持细粒度的对象复用，细粒度对象是可以共享的内部状态的对象。

- 本质：分离与共享

- 类图：

  ![](https://i.loli.net/2020/06/11/V9UDSFm3gHMqfWP.png)

  - Flyweight（享元抽象类）:通常是一个接口或者抽象类，在享元抽象类中声明了公共方法，提供内部状态共享对象和设置外部状态方法。
  - ConcreteFlyweight（具体享元类）：具体享元类实现了享元抽象类中的方法，提供共享细粒度的对象，并提供内部状态的对象，一般采用单例模式设计，避免被实例化。
  - UnsharedConcreteFlyweight（非共享具体享元类）：可以实现享元抽象类，也可以不用实现享元抽象类，可以设置外部状态的对象，可以自行实例化对象。
  - FlyweightFactory（享元工厂类）：创建并管理享元对象，享元工厂类中，创建享元池，用于获取享元对象，如果不存在则创建享元对象。

- 实现：

  ```java
  package com.learn.design.pattern.flyweight;
  
  /**
   * Flyweight（享元抽象类）
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/20 10:35
   * @desc
   */
  public abstract class WebSite {
      /**
       * 享元公共方法
       * @param user
       */
      public abstract void published(User user);
  }
  ```

  ```java
  package com.learn.design.pattern.flyweight;
  
  /**
   * ConcreteFlyweight（具体享元类）
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/23 18:17
   * @desc
   */
  public class ConcreteWebSite extends WebSite {
  
      private String type;
  
      public ConcreteWebSite(String type) {
          this.type = type;
      }
  
      @Override
      public void published(User user) {
          System.out.println("用户：" + user.getName() + ",发布网站内容:" + this.type);
      }
  }
  ```

  ```java
  package com.learn.design.pattern.flyweight;
  
  import org.springframework.util.CollectionUtils;
  
  import java.util.Map;
  import java.util.concurrent.ConcurrentHashMap;
  
  /**
   * FlyweightFactory（享元工厂类）
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/23 18:23
   * @desc
   */
  public class WebSiteFactory {
      /**
       * 对象池
       */
      private Map<String, WebSite> websiteMap = new ConcurrentHashMap<String, WebSite>();
  
      private WebSiteFactory() {
      }
  
      /**
       * 单例内部类
       */
      private static class inner {
          public static WebSiteFactory getInstance() {
              return new WebSiteFactory();
          }
  
      }
  
      public static WebSiteFactory getFactory() {
          return inner.getInstance();
      }
  
      /**
       * 获取享元池对象
       *
       * @param type
       * @return
       */
      public WebSite getWebSite(String type) {
          if (!CollectionUtils.isEmpty(websiteMap)) {
              if (websiteMap.containsKey(type)) {
                  return websiteMap.get(type);
              }
          }
          WebSite webSite = new ConcreteWebSite(type);
          websiteMap.put(type, webSite);
          return webSite;
      }
  }
  ```

  ```java
  package com.learn.design.pattern.flyweight;
  
  /**
   * UnsharedConcreteFlyweight（非共享具体享元类）
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/23 18:13
   * @desc
   */
  public class User {
      private String name;
      private int age;
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  }
  ```

  ```java
  package com.learn.design.pattern.flyweight;
  
  /**
   * 测试
   *
   * @author ycz
   * @version 1.0
   * @date 2020/5/23 18:34
   * @desc
   */
  public class Cilent {
  
      public static void main(String[] args) {
          User user = new User();
          user.setAge(20);
          user.setName("张三");
          WebSiteFactory webSiteFactory = WebSiteFactory.getFactory();
          WebSite news = webSiteFactory.getWebSite("News");
          news.published(user);
          WebSite news1 = webSiteFactory.getWebSite("News");
          news1.published(user);
          System.out.println(news == news1);
          WebSite blog = webSiteFactory.getWebSite("Blog");
          blog.published(user);
      }
  }
  
  用户：张三,发布网站内容:News
  用户：张三,发布网站内容:News
  true
  用户：张三,发布网站内容:Blog
  ```

  

### 7、代理模式

- 定义：给某个对象提供代理对象，并由代理对象控制原对象的引用。

- 本质：控制对象的访问。

- 类图：

  ![](https://i.loli.net/2020/06/11/QSqtZLlvYsKCWkA.png)

  - Subject（抽象主题角色）：它被代理对象，提供代理主题和真实主题共同的接口。
  - Proxy（代理主题角色）：它实现抽象主题角色方法，持有真实主题角色的引用，通过引用调用真实主题对象，是代理模式的核心类。
  - RealSubject（真实主题角色）：实现抽象主题角色的方法，它是真正业务操作的最终方法。

- 实现：

  - 静态代理

    - 聚合方式

      ```java
      package com.learn.design.pattern.proxy.statics.inherit;
      
      /**
       * Subject(抽象主题角色)
       *
       * @author ycz
       * @version 1.0
       * @date 2020/5/23 23:21
       * @desc
       */
      public interface UserService {
          /**
           * 实现登录方法
           *
           * @param name
           */
          void login(String name);
      }
      ```

      ```java
      package com.learn.design.pattern.proxy.statics.inherit;
      
      /**
       * RealSubject(真实主题角色)
       *
       * @author ycz
       * @version 1.0
       * @date 2020/5/23 23:28
       * @desc
       */
      public class UserServiceImpl implements UserService {
          @Override
          public void login(String name) {
              System.out.println("用户：" + name + "，登录成功");
          }
      }
      ```

      ```java
      package com.learn.design.pattern.proxy.statics.inherit;
      
      /**
       * Proxy(代理主题对象)
       *
       * @author ycz
       * @version 1.0
       * @date 2020/5/23 23:29
       * @desc
       */
      public class UserProxy implements UserService {
          //真实主题角色
          private UserService userService;
      
          public UserProxy(UserService userService) {
              this.userService = userService;
          }
      
          @Override
          public void login(String name) {
              System.out.println("开始调用代理对象");
              userService.login(name);
              System.out.println("调用代理对象结束");
          }
      }
      ```

      ```java
      package com.learn.design.pattern.proxy.statics.inherit;
      
      /**
       * 客户端类
       * @author ycz
       * @version 1.0
       * @date 2020/5/23 23:32
       * @desc
       */
      public class Client {
      
          public static void main(String[] args) {
              UserService userService=new UserServiceImpl();
              UserService userProxy=new UserProxy(userService);
              userProxy.login("张三");
          }
      }
      ```

      

    - 继承方式

      ```java
      package com.learn.design.pattern.proxy.statics.inherit;
      
      /**
       * Subject(抽象主题角色)
       *
       * @author ycz
       * @version 1.0
       * @date 2020/5/23 23:21
       * @desc
       */
      public interface UserService {
          /**
           * 实现登录方法
           *
           * @param name
           */
          void login(String name);
      }
      ```

      ```java
      package com.learn.design.pattern.proxy.statics.inherit;
      
      /**
       * RealSubject(真实主题角色)
       *
       * @author ycz
       * @version 1.0
       * @date 2020/5/23 23:28
       * @desc
       */
      public class UserServiceImpl implements UserService {
          @Override
          public void login(String name) {
              System.out.println("用户：" + name + "，登录成功");
          }
      }
      ```

      ```java
      package com.learn.design.pattern.proxy.statics.inherit;
      
      /**
       * Proxy(代理主题对象)
       *
       * @author ycz
       * @version 1.0
       * @date 2020/5/23 23:29
       * @desc
       */
      public class UserProxy extends UserServiceImpl {
      
          @Override
          public void login(String name) {
              System.out.println("开始调用代理对象");
              super.login(name);
              System.out.println("调用代理对象结束");
          }
      }
      ```

      ```java
      package com.learn.design.pattern.proxy.statics.inherit;
      
      /**
       * 客户端类
       * @author ycz
       * @version 1.0
       * @date 2020/5/23 23:32
       * @desc
       */
      public class Client {
      
          public static void main(String[] args) {
              UserService userProxy=new UserProxy();
              userProxy.login("张三");
          }
      }
      ```

      

  - 动态代理
    - jdk代理方式
    - cglib代理方式

## 三、行为型模式

### 1、职责链模式

- 定义：避免发送者与接收者耦合在一起，让多个对象都可以接受请求，将这些对象串成一条链，沿着这条链传递请求，直到处理完成为止。

- 本质：分离职责，动态组合。

- 类图：
  
  ![](https://i.loli.net/2020/06/11/4ydoJDuthIvk8Oz.png)
  
  - Handler(抽象处理者)：定义下一个处理请求接口，并且持有下一个调用链handler实例。
  - ConcreteHandler(具体处理者)：处理请求接口逻辑实现，处理成功后继续调用下一个处理者。
  
- 实现：

  ```java
  package com.learn.design.pattern.chain;
  
  /**
   * 等同于类图中Handler抽象类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 10:28
   * @desc
   */
  interface Filter {
  
      /**
       * 处理请求接口
       * @param type
       * @param filterChain
       */
      void doFilter(String type, FilterChain filterChain);
  }
  ```

  ```java
  package com.learn.design.pattern.chain;
  
  /**
   * 具体处理者
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 11:20
   * @desc
   */
  public class HttpFilter implements Filter {
  
      @Override
      public void doFilter(String type, FilterChain chain) {
          System.out.println("调用HttpFilter处理，type=" + type);
          chain.doChain(type);
      }
  }
  ```

  ```java
  package com.learn.design.pattern.chain;
  
  /**
   * 具体请求执行者
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 10:30
   * @desc
   */
  public class WebFilter implements Filter {
  
      @Override
      public void doFilter(String type, FilterChain chain) {
          System.out.println("调用webFilter链处理，type=" + type);
          chain.doChain(type);
      }
  }
  ```

  ```java
  package com.learn.design.pattern.chain;
  
  import java.util.ArrayList;
  import java.util.Iterator;
  import java.util.List;
  
  /**
   * 责任链集合
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 10:29
   * @desc
   */
  public class FilterChain {
      /**
       * Filter集合
       */
      private List<Filter> filters = new ArrayList<>();
      /**
       * 下一个调用链
       */
      private Iterator<Filter> nextIterator;
  
      /**
       * 添加调用链
       *
       * @param filter
       * @return
       */
      public boolean addFilter(Filter filter) {
          return filters.add(filter);
      }
  
      /**
       * 调用下个链
       *
       * @param type
       */
      public void doChain(String type) {
          if (this.nextIterator == null) {
              this.nextIterator = this.filters.iterator();
          }
          if (this.nextIterator.hasNext()) {
              Filter filter = this.nextIterator.next();
              filter.doFilter(type, this);
          }
      }
  }
  ```

  ```java
  package com.learn.design.pattern.chain;
  
  /**
   * 测试类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 9:58
   * @desc
   */
  public class Client {
  
      public static void main(String[] args) {
          Filter webFilter=new WebFilter();
          Filter httpFilter=new HttpFilter();
          FilterChain filterChain=new FilterChain();
          filterChain.addFilter(httpFilter);
          webFilter.doFilter("hello",filterChain);
      }
  }
  ```

  

### 2、命令模式

- 定义：
- 本质：
- 类图：
- 实现：

### 3、解释器模式

- 定义：
- 本质：
- 类图：
- 实现：

### 4、迭代器模式
- 定义：
- 本质：
- 类图：
- 实现：

### 5、中介者模式
- 定义：
- 本质：
- 类图：
- 实现：

### 6、备忘录模式
- 定义：
- 本质：
- 类图：
- 实现：

### 7、观察者模式
- 定义：
- 本质：
- 类图：
- 实现：

### 8、状态模式
- 定义：
- 本质：
- 类图：
- 实现：
### 9、策略模式

- 定义：定义一系列算法类，将每个算法封装起来，并可以互相替换，让算法供给客户选择.

- 本质：分离算法，选择实现。

- 类图：

  ![](https://i.loli.net/2020/06/11/762ZujR8F9ixStc.png)

  - Context（环境类）：使用算法的角色，持有抽象策略类的引用，用于调用具体策略实现类。
  - Strategy（抽象策略类）：定义抽象算法策略方法，该类可以是接口或者抽象类。
  - ConcreteStrategy（具体策略类）：具体抽象策略算法的实现。

- 实现：

  ```java
  package com.learn.design.pattern.strategy;
  
  /**
   * 环境类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 14:38
   * @desc
   */
  public class Context {
      /**
       * 抽象策略类
       */
      private Strategy strategy;
  
      public Context(Strategy strategy) {
          this.strategy = strategy;
      }
  
      /**
       * 调用具体策略算法
       */
      public void algorithm() {
          strategy.algorithm();
      }
  }
  ```

  ```java
  package com.learn.design.pattern.strategy;
  
  /**
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 14:39
   * @desc
   */
  public interface Strategy {
      /**
       * 抽象策略算法
       */
      void algorithm();
  }
  ```

  ```java
  package com.learn.design.pattern.strategy;
  
  /**
   * 具体策略实现
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 14:40
   * @desc
   */
  public class ConcreteStrategyA implements Strategy {
  
      @Override
      public void algorithm() {
          System.out.println("调用--策略A处理");
      }
  }
  ```

  ```java
  package com.learn.design.pattern.strategy;
  
  /**
   * 具体策略实现
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 14:40
   * @desc
   */
  public class ConcreteStrategyB implements Strategy {
      @Override
      public void algorithm() {
          System.out.println("调用--策略B处理");
      }
  }
  ```

  ```java
  package com.learn.design.pattern.strategy;
  
  /**
   * 测试类
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 14:41
   * @desc
   */
  public class Client {
  
      public static void main(String[] args) {
          Strategy strategy=new ConcreteStrategyA();
          Context context=new Context(strategy);
          context.algorithm();
      }
  }
  ```

### 10、模板方法模式

- 定义：定义一个算法框架，而将一些步骤延迟到子类实现，模板方法使得子类不改变算法的结构，可以重新定义某些特定的步骤。

- 本质：固定算法骨架

- 类图：

  ![](https://i.loli.net/2020/06/11/9gF7DqpJieK46RA.png)

  - AbstractClass（抽象模板类）：定义模板方法，定义特定抽象方法给子类实现，增加钩子函数，增加模板灵活性。
  - ConcreteClass（具体模板类）：实现抽象模板类的抽象方法，有特定的场景需要重写钩子函数。

- 实现：

  - 普通模式

    ```java
    package com.learn.design.pattern.template;
    
    /**
     * 用户信息
     * @author ycz
     * @version 1.0
     * @date 2020/6/9 16:15
     * @desc
     */
    public class User {
        /**
         * 用户ID
         */
        private Integer id;
        /**
         * 用户名称
         */
        private String name;
        /**
         * 用户密码
         */
        private String password;
    
        public Integer getId() {
            return id;
        }
    
        public void setId(Integer id) {
            this.id = id;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getPassword() {
            return password;
        }
    
        public void setPassword(String password) {
            this.password = password;
        }
    }
    ```

    ```java
    package com.learn.design.pattern.template;
    
    /**
     * 登录模板方法
     *
     * @author ycz
     * @version 1.0
     * @date 2020/6/9 16:13
     * @desc
     */
    abstract class LoginTemplate {
        /**
         * 是否是超级用户(钩子)
         */
        private boolean isSuperUser;
    
        /**
         * 用户信息（模板方法）
         *
         * @param user
         */
        public boolean login(User user) {
            if (!isSuperUser()) {
                System.out.println("非超级用户必须查询用户信息");
                User findUser = this.findUser(user);
                if (findUser == null) {
                    return false;
                }
            }
            return this.match(user);
        }
    
        /**
         * 查询用户信息
         *
         * @param user
         * @return
         */
        private User findUser(User user) {
            //获取数据库用户信息，为了测试方便
            if (user.getId() == null) {
                return null;
            }
            return user;
        }
    
        /**
         * 匹配用户账号密码
         *
         * @param user
         * @return
         */
        protected abstract boolean match(User user);
    
        /**
         * 钩子函数(默认非超级用户)
         *
         * @return
         */
        protected boolean isSuperUser() {
            return false;
        }
    }
    ```

    ```java
    package com.learn.design.pattern.template;
    
    /**
     * 普通用户具体模板子类
     *
     * @author ycz
     * @version 1.0
     * @date 2020/6/9 16:29
     * @desc
     */
    public class OrdinaryUser extends LoginTemplate {
    
        @Override
        public boolean match(User user) {
            System.out.println("调用普通用户匹配账号密码，名称：" + user.getName());
            if (user.getName() != null && "ordinary".equals(user.getName())) {
                return true;
            }
            return false;
        }
    }
    ```

    ```java
    package com.learn.design.pattern.template;
    
    /**
     * 具体实现模板子类
     *
     * @author ycz
     * @version 1.0
     * @date 2020/6/9 16:31
     * @desc
     */
    public class SuperUser extends LoginTemplate {
    
        @Override
        public boolean match(User user) {
            System.out.println("调用超级用户账号密码，用户名称：" + user.getName());
            if ("admin".equals(user.getName())) {
                return true;
            }
            return false;
        }
    
        @Override
        public boolean isSuperUser() {
            return true;
        }
    }
    ```

    ```java
    package com.learn.design.pattern.template;
    
    /**
     * 测试类
     *
     * @author ycz
     * @version 1.0
     * @date 2020/6/9 16:38
     * @desc
     */
    public class Client {
    
        public static void main(String[] args) {
            ordinaryLogin();
            superLogin();
        }
    
        private static void ordinaryLogin() {
            User ordinary = new User();
            ordinary.setId(1);
            ordinary.setName("ordinary");
            ordinary.setPassword("123456");
            LoginTemplate loginTemplate = new OrdinaryUser();
            boolean isLogin = loginTemplate.login(ordinary);
            System.out.println("登录是否成功：" + isLogin);
        }
    
        private static void superLogin() {
            User ordinary = new User();
            ordinary.setId(1);
            ordinary.setName("admin");
            ordinary.setPassword("123456");
            LoginTemplate loginTemplate = new SuperUser();
            boolean isLogin = loginTemplate.login(ordinary);
            System.out.println("登录是否成功：" + isLogin);
        }
    }
    ```

  - 回调模式

### 11、访问者模式

- 定义：提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

- 本质：预留通路，回调实现。

- 类图：

  ![](https://i.loli.net/2020/06/11/BywgSEQUHXI3j79.png)

  - Visitor（抽象访问者）：抽象访问者定义每个具体元素类声明一个访问操作，声明具体方法名类型。
  - ConcreteVisitor（具体访问者）：具体访问者实现每个抽象访问声明操作。
  - Element（抽象元素）：抽象元素一般抽象类或接口，它定义了一个accept(Visitor visitor)方法。
  - ConcreteElement（具体元素）：具体元素实现了accept方法，在accept方法中调用了访问者访问方法。
  - ObjectStructure（对象结构）：对象结构是一各元素集合，它存放元素对象，并且提供遍历内部元素的方法。

- 实现：

  ```java
  package com.learn.design.pattern.visitor;
  
  /**
   * 抽象元素
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 17:37
   * @desc
   */
  public interface Element {
      /**
       * 定义accept方法
       * @param visitor
       */
      void accept(Visitor visitor);
  }
  ```

  ```java
  package com.learn.design.pattern.visitor;
  
  /**
   * 具体元素抽象方法
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 17:38
   * @desc
   */
  public class ElementA implements Element {
      private String name;
  
      private int age;
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      @Override
      public void accept(Visitor visitor) {
          this.name = "张三";
          this.age = 17;
          visitor.visitorElementA(this);
      }
  }
  ```

  ```java
  package com.learn.design.pattern.visitor;
  
  /**
   * 具体元素
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 17:39
   * @desc
   */
  public class ElementB implements Element {
      private String name;
  
      private int age;
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      @Override
      public void accept(Visitor visitor) {
          this.name = "李四";
          this.age = 50;
          visitor.visitorElementB(this);
      }
  }
  ```

  ```java
  package com.learn.design.pattern.visitor;
  
  import java.util.ArrayList;
  import java.util.Iterator;
  import java.util.List;
  
  /**
   * 对象结构
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 17:40
   * @desc
   */
  public class ObjectStructure {
      /**
       * 对象集合
       */
      private List<Element> elementList = new ArrayList<>();
  
      /**
       * 开始调用访问者
       *
       * @param visitor
       */
      public void accept(Visitor visitor) {
          Iterator<Element> iterator = elementList.iterator();
          while (iterator.hasNext()) {
              Element element = iterator.next();
              element.accept(visitor);
          }
      }
  
      /**
       * 添加元素
       *
       * @param element
       */
      public boolean addElement(Element element) {
          return elementList.add(element);
      }
  
      /**
       * 移除元素
       *
       * @param element
       */
      public boolean removeElement(Element element) {
          if (elementList != null && elementList.size() > 0) {
              return elementList.remove(element);
          }
          return false;
      }
  }
  ```

  ```java
  package com.learn.design.pattern.visitor;
  
  /**
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 17:35
   * @desc
   */
  public interface Visitor {
      /**
       * @param elementA
       */
      void visitorElementA(ElementA elementA);
  
      /**
       * @param elementB
       */
      void visitorElementB(ElementB elementB);
  }
  ```

  ```java
  package com.learn.design.pattern.visitor;
  
  /**
   * 具体访问者实现
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 17:36
   * @desc
   */
  public class ConcreteVisitorA implements Visitor {
  
      @Override
      public void visitorElementA(ElementA elementA) {
          System.out.println("具体访问者实现A");
          if (elementA.getAge() < 18) {
              System.out.println(elementA.getName() + ",未成年");
          } else {
              System.out.println(elementA.getName() + ",已经成人");
          }
      }
  
      @Override
      public void visitorElementB(ElementB elementB) {
          System.out.println("具体访问者实现A");
          if (elementB.getAge() < 18) {
              System.out.println(elementB.getName() + ",未成年");
          } else {
              System.out.println(elementB.getName() + ",已经成人");
          }
      }
  }
  ```

  ```java
  package com.learn.design.pattern.visitor;
  
  /**
   * 具体访问者实现
   *
   * @author ycz
   * @version 1.0
   * @date 2020/6/9 17:40
   * @desc
   */
  public class ConcreteVisitorB implements Visitor {
  
      @Override
      public void visitorElementA(ElementA elementA) {
          System.out.println("具体访问者实现B");
          if (elementA.getAge() < 18) {
              System.out.println(elementA.getName() + ",未成年");
          } else {
              System.out.println(elementA.getName() + ",已经成人");
          }
      }
  
      @Override
      public void visitorElementB(ElementB elementB) {
          System.out.println("具体访问者实现B");
          if (elementB.getAge() < 18) {
              System.out.println(elementB.getName() + ",未成年");
          } else {
              System.out.println(elementB.getName() + ",已经成人");
          }
      }
  }
  ```
