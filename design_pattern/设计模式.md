# 设计模式

## 一、面向对象设计原则

### 1、单一职责原则

​	 **定义：**一个类只负责一个功能领域中的相应的职责，也就是说类的设计尽量只有一个原因引起变化。**（最简单也应用最难运用的原则）**

### 2、开闭原则

​    **定义：**一个软件实体应该对扩展的开放，对修改的关闭。**也就是如何不修改原有的代码基础上，进行扩展。**

**规则：**

- 抽象约束
  - 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许接口或者抽象类存在非public方法。
  - 参数类型、引用类型尽量使用接口或者抽象类，而不是具体实现类。
  - 抽象层一定要保持稳定，一旦确定即不允许修改。
- 元数据控制模型行为  
  - 基于配置文件实例化对象，例如spring的IOC

-  制定项目章程
  - 制定出一套开发规范，避免后续难以扩展。
- 封装变化
  - 把变化的部分放到抽象类或者接口上
  - 把不同变化，应该封装到不同变换接口或者抽象类上。

### 3、里氏代换原则

​	**定义：**在软件中使用基类（父类）替代它的子类，不会出现程序错误和异常，反过来则不成立。开发尽量使用基类，而不是子类，方便程序扩展。

​	**规则：**

- 子类完全实现父类的方法，如果不能满足父类所有方法，那么就脱离继承关系，改成依赖、组合、聚集等的方式替代。
- 子类可以有自己个性的方法。

### 4、依赖倒置原则

- **定义：**抽象（接口和抽象类）不应该依赖细节（具体实现类），细节应该依赖于抽象。换言之，要**面向接口编程**，而不是实现编程。
- **实现依赖方式：**
  - 构造函数传递依赖对象。
  - setter方式注入依赖对象。
  - 接口声明依赖对象（依赖注入）。
- **规则：**
  - 每个类尽量有接口或者抽象类，或者两者都具备。
  - 变量的类型尽量是接口或者抽象类引用。
  - 任何类都不应该从具体类派生。
  - 尽量不要覆写基类的方法。

### 5、接口隔离原则

- **定义：**使用多个专门接口（类似定制服务），而不是建立单一的总接口上。**（普通类也属于接口，是实例接口）**
  - 客户端不应该依赖那些它不需要的接口。
  - 类之间的依赖应该是在最小的接口上。
- **规则**
  - 接口要尽量小
    - 接口隔离拆分粒度时，要满足单一职责原则。
  - 接口要高内聚
    - 高内聚就是提高接口、类和模块处理能力，减少对外界交互，言外之意尽量少的提供接口给外部。
  - 定制服务
    - 提供专门定制的接口。
  - 接口设计有限度
    - 接口粒度需要根据经验和常识判断，而不是一味小的的接口，带来结构复杂化。
- **实践**
  - 一个接口只服用一个子模块或者业务逻辑。
  - 通过业务逻辑压缩接口public方法，而不是一堆方法。
  - 已经被污染的接口，尽量去修改，如果无法修改，采用适配器模式进行转化。
  - 了解环境，拒绝盲从，根据实际业务逻辑情况，而不是盲目跟风。

### 6、合成复用原则

- **定义：**尽量使用对象组合，而不是继承来达到复用的原则。

### 7、迪米特原则

- **定义：**一个软件实体尽可能少与其他实体发生相互作用，就是减少类之间相互依赖，降低类的耦合度，提高复用性。

## 二、创建型模式

### 1、单例模式

- **定义：**确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

  - **优点**
    - 只有一个实例，减少内存开支，避免频繁创建和销毁。
    - 提供全局访问点和共享资源访问。

  - **缺点**
    - 不易扩展，代码复用性低。
    - 违法单一职责原则。

  - **场景**
    - 要求生成唯一序列号的环境。
    - 大量静态常量和静态方法时，比如工具类。
    - 创建对象需要消耗大量资源，比如数据库和IO资源等。

- **实现：**

  - **实现要点：**

    - **私有化构造方法。**

    - **获取实例化方法使用static方法。**

    - **保证实例化对象线程安全。**

    - **饿汉式模式**

      ```java
      /**
       * 饿汉单例模式
       */
      public class EagerSingleton {
          
          private static final EagerSingleton instance = new EagerSingleton();
          
          private EagerSingleton() {
      
          }
          
          public static EagerSingleton getInstance() {
              return instance;
          }
      }
      ```

    - **懒汉式模式**

      ```java
      /**
       * 懒汉式模式
       */
      public class LazySingleton {
      
          private static LazySingleton instance = null;
      
          private LazySingleton() {
      
          }
          
          public static synchronized LazySingleton getInstance() {
              if (instance == null) {
                  instance = new LazySingleton();
                  return instance;
              }
              return instance;
          }
      }
      ```

    - **双重检查锁**

      ```java
      /**
       * 双重检查锁模式
       */
      public class DoubleCheckLockSingleton {
          /**
           * 解决指令重排和可见性
           */
          private static volatile DoubleCheckLockSingleton instance = null;
      
          private DoubleCheckLockSingleton() {
      
          }
      
          public static DoubleCheckLockSingleton getInstance() {
              if (instance == null) {
                  synchronized (DoubleCheckLockSingleton.class) {
                      if (instance == null) {
                          instance = new DoubleCheckLockSingleton();
                          return instance;
                      }
                  }
              }
              return instance;
          }
      
      }
      ```

    - **静态内部类模式**

      ```java
      /**
       * 静态内部类实现
       */
      public class StaticInnerSingleton {
      
          private StaticInnerSingleton() {
      
          }
      
          private static class HoldClass {
              private final static StaticInnerSingleton instance = new StaticInnerSingleton();
          }
      
          public static StaticInnerSingleton getInstance() {
              return HoldClass.instance;
          }
      
          public static void main(String[] args) {
              StaticInnerSingleton singleton1 = StaticInnerSingleton.getInstance();
              StaticInnerSingleton singleton2 = StaticInnerSingleton.getInstance();
              StaticInnerSingleton singleton3 = StaticInnerSingleton.getInstance();
              System.out.println(singleton1 == singleton2);
              System.out.println(singleton1 == singleton3);
              System.out.println(singleton2 == singleton3);
          }
      }
      ```

    - **枚举模式**

      ```java
      /**
       * 枚举模式
       */
      public enum EunmSingleton {
      
          instance;
      
          public static EunmSingleton getInstance() {
              return instance;
          }
      
          public static void main(String[] args) {
              EunmSingleton singleton1=EunmSingleton.getInstance();
              EunmSingleton singleton2=EunmSingleton.getInstance();
              EunmSingleton singleton3=EunmSingleton.getInstance();
              System.out.println(singleton1 == singleton2);
              System.out.println(singleton1 == singleton3);
              System.out.println(singleton2 == singleton3);
              /***
               * true
               * true
               * true
               */
          }
      }
      ```

      

### 2、简单工厂模式

- **定义：**定义一个工厂类，根据参数不同返回不同的实例，返回被创建的实例都有共同的父类。因为工厂类中的获取实例的方法是静态（static）方法，也被称静态工厂方法模式。

- **类图：**

  ![image-20200424104755409](F:%5Ctypora%5Cdesign_pattern%5C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets%5Cimage-20200424104755409.png)

  - **Factory（工厂角色）：**负责创建具体产品实例化对象，提供静态工厂方法给外部调用，返回抽象产品类型Product。
  - **Product（抽象产品角色）：**产品抽象类，具体产品的父类，提供公有方法。
  - **ConcreateProduct（具体产品角色）：**具体产品继承抽象类，具体实例化的产品。

- **实现：**

  ```
  /**
   * 抽象产品类
   */
  public abstract class Product {
      /**
       * 抽象产品
       */
      abstract void operate();
  }
  ```

  ```
  /**
   * 具体产品类
   */
  public class ConCreateProduct extends Product {
  
      @Override
      void operate() {
          System.out.println("ConCreateProduct Instance  Success");
      }
  }
  ```

  ```
  /**
   * 工厂类
   */
  public class SimpleFactory {
      /**
       * 抽象静态工厂方法
       *
       * @param type
       * @return
       */
      public static Product createProduct(int type) {
          if (type == 1) {
              return new ConCreateProduct();
          }
          throw new RuntimeException("type  no exist instance , please check!");
      }
  }
  ```

  ```java
  /**
   * 客户端
   */
  public class Client {
  
      public static void main(String[] args) {
          Product product = SimpleFactory.createProduct(2);
          product.operate();
      }
  }
  
  ```

### **3、简单工厂方法模式**

- **定义：**定义一个用于创建对象的接口，让子类决定哪个类进行实例化

- **类图：**

  ![image-20200426180934653](F:%5Ctypora%5Cdesign_pattern%5C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets%5Cimage-20200426180934653.png)

  - **Product（抽象产品）：**抽象产品类，封装产品公共方法和抽象方法，延迟到子类实现。
  - **ConcreateProduct（具体产品）：**实现抽象产品类，具体产品与具体工厂类一一对应。
  - **AbstractFactory（抽象工厂）：**抽象工厂类，封装工厂方法，具体实现延迟到子类，返回一个产品。
  - **ConcreateFactory（具体工厂类）：**实现抽象工厂类，实现抽象方法，返回具体产品的实例。

- **实现：**

  ```java
  /**
   * 抽象产品
   */
  abstract class Product {
      /**
       * 产品公共方法
       */
      abstract void show();
  }
  ```

  ```java
  
  /**
   * 具体产品A实现
   */
  public class ConcreateProductA extends Product {
      @Override
      void show() {
          System.out.println("show A product.....");
      }
  }
  ```

  ```java
  /**
   * 具体产品B实现
   */
  public class ConcreateProductB extends Product {
      @Override
      void show() {
          System.out.println("show B product.....");
      }
  }
  ```

  ```java
  /**
   * 抽象工厂类
   */
  public abstract class AbstractFactory {
      /**
       * 抽象工厂方法一
       *
       * @param tClass
       * @param <T>
       * @return
       */
      abstract <T extends Product> T createProduct(Class<T> tClass);
      /**
       * 抽象工厂方法二
       * @return
       */
      abstract Product createProduct();
  }
  ```

  ```java
  /**
   * 具体产品实现类
   */
  public class ConcreateFactoryA extends AbstractFactory {
  
      private static final Logger logger = LoggerFactory.getLogger(ConcreateFactoryA.class);
  
      @Override
      <T extends Product> T createProduct(Class<T> tClass) {
          try {
              return (T) Class.forName(tClass.getName()).newInstance();
          } catch (Exception e) {
              logger.error("new instance,exception{}", e.getMessage());
          }
          return null;
      }
       @Override
      Product createProduct() {
          return new ConcreateProductA();
      }
  }
  ```

  ```java
  /**
   * 具体B产品抽象工厂类
   */
  public class ConcreateFactoryB extends AbstractFactory {
  
      private static final Logger logger = LoggerFactory.getLogger(ConcreateFactoryB.class);
  
      @Override
      <T extends Product> T createProduct(Class<T> tClass) {
          try {
              return (T) Class.forName(tClass.getName()).newInstance();
          } catch (Exception e) {
              logger.error("new instance,exception:{}", e.getMessage());
          }
          return null;
      }
       @Override
      Product createProduct() {
          return new ConcreateProductB();
      }
  }
  ```

### **4、抽象工厂模式**

- **定义：**定义一系列抽象方法或相互依赖对象的接口，而无需指定具体产品类。

- **类图：**

  ![image-20200428170006187](F:%5Ctypora%5Cdesign_pattern%5C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets%5Cimage-20200428170006187.png)

  - **AbstractFactory(抽象工厂)：**创建一系列抽象方法，每个方法对应着一个具体产品。
  - **ConcreateFactory(具体工厂)：**实现抽象工厂方法，并创建具体产品。
  - **AbstractProduct(抽象产品)：**定义抽象产品方法和公共业务方法。
  - **ConcreateProduct(具体产品)：**具体产品实现抽象产品业务方法。

- **实现：**

  ```java
  /**
   * 抽象工厂方法
   */
  public abstract class AbstractFactory {
      /**
       * 抽象产品A
       *
       * @return
       */
      public abstract AbstractProductA createProductA();
  
      /**
       * 抽象产品B
       *
       * @return
       */
      public abstract AbstractProductB createProductB();
  }
  ```

  ```java
  /**
   * 创建产品A
   */
  public class ConcreateFactoryProductA extends AbstractFactory {
      @Override
      public AbstractProductA createProductA() {
          return new ProductA1();
      }
  
      @Override
      public AbstractProductB createProductB() {
          return new ProductB1();
      }
  }
  ```

  ```java
  
  /**
   * 创建产品B
   */
  public class ConcreateFactoryProductB extends AbstractFactory {
      @Override
      public AbstractProductA createProductA() {
          return new ProductA2();
      }
  
      @Override
      public AbstractProductB createProductB() {
          return new ProductB2();
      }
  }
  ```

  ```java
  /**
   * 抽象产品A
   */
  public abstract class AbstractProductA {
      /**
       * 抽象产品公用类
       */
      public abstract void show();
  }
  ```

  ```java
  public class ProductA1 extends AbstractProductA {
      @Override
      public void show() {
          System.out.println("产品A1...........");
      }
  }
  ```

  ```java
  public class ProductA2 extends AbstractProductA {
      @Override
      public void show() {
          System.out.println("产品A2........");
      }
  }
  ```

  ```java
  /**
   * 抽象产品B
   */
  public abstract class AbstractProductB {
      /**
       * 抽象类公共方法
       */
      public abstract void show();
  }
  ```

  ```java
  public class ProductB1 extends AbstractProductB {
      @Override
      public void show() {
          System.out.println("产品B1.....");
      }
  }
  ```

  ```java
  public class ProductB2 extends AbstractProductB {
      @Override
      public void show() {
          System.out.println("产品B2.........");
      }
  }
  ```

### **5、原型模式**

- **定义：**
- **类图：**
- **实现：**

### **6、建造者模式**

- **定义：**
- **类图：**
- **实现：**

## 二、结构型模式

## 三、行为型模式